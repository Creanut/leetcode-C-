/*
给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。

网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

 

示例 :

输入:
[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]

输出: 16

*/

int islandPerimeter(int** grid, int gridSize, int* gridColSize)
{
    if(grid == NULL || gridSize == 0)
        return 0;
    
    int circum = 0;
    
    for(int i = 0; i < gridSize; i++)
    {
        for(int j = 0; j < *gridColSize; j++)
        {
            if(grid[i][j] == 1)
            {
                circum = circum + 4;
                if(i > 0 && grid[i-1][j] == 1)
                    circum = circum - 2;
                if(j > 0 && grid[i][j-1] == 1)
                    circum = circum - 2;
            }
        }
    }
    
    return circum;
}

/*
虽说是二维数组操作，但是要想明白单个正方形边长的计数逻辑。
遍历二维数组的时候，如果遇到小岛，周长先自加4，即把所有的边长都当作是有效边长，
然后考察这个小岛的左侧和上侧有没有相邻的小岛，如果有，则需要去掉两个边（相邻小岛
会各减去一条边），这里需要注意边界问题，以上侧和左侧为标准，则第一行和第一列中
的小岛要注意，其没有上和左，因此为防止数组索引出界，要在判断时加上附加条件。
*/
