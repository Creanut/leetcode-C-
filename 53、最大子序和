/*
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
*/

//以下方法是最朴素的方法，时间复杂度是O(n^2)级别的
int maxSubArray(int* nums, int numsSize) 
{
    int sum;
    int max = INT_MIN;
    
    for(int i = 0; i < numsSize; i++)//定义求和区间的左起点，外层遍历数组中的所有的值
    {
        sum = 0;
        for(int j = i; j < numsSize; j++)//定义求和区间的右终点，以左起点为根，区间逐渐外扩并计算累加和
        {
            sum = sum + nums[j];
            if(sum > max)//寻找最大和
                max = sum;
        }
    }
    return max;
}

//以下方法是看到的进阶版本，扫描法，时间复杂度是O(n)【不过这个算法证明起来真的好绕】
int maxSubArray(int* nums, int numsSize) 
{
    int sum = nums[0];
    int now = nums[0];
    
    for(int i = 1; i < numsSize; i++)
    {
        if(now < 0)
            now = nums[i];//要么是只包含第i个元素
        else
            now = now + nums[i];//要么是以第i-1个元素结尾且和最大的连续子数组加上这个元素
        
        if(now > sum)
            sum = now;//记录前一次的结果
    }
    return sum;
}

/*
对于第一种最朴素的方法，其核心思想就是枚举法。
一个有n个元素的集合，它的子集个数为n^2个，如果把它的子集的和全部求出来，并在其中找到最大的，即是题解；
所以对于朴素解法，外层循环指定子序列的左起点，内层循环指定子序列的终点，然后计算每一个子序列的和，
找出计算结果的最大值即可。

对于第二种方法，可以理解为是一个动态规划问题。
设sum[i]为以第i个元素结尾且和最大的连续子数组，
假设对于元素i，所有以它前面的元素结尾的子数组的长度都已经求得，
那么以第i个元素结尾且和最大的连续子数组，实际上，要么是以第i-1个元素结尾且和最大的连续子数组加上这个元素，要么是只包含第i个元素，
即sum[i] = max(sum[i-1] + a[i], a[i])。
可以通过判断sum[i-1] + a[i]是否大于a[i]来做选择，而这实际上等价于判断sum[i-1]是否大于0。
由于每次运算只需要前一次的结果，因此并不需要像普通的动态规划那样保留之前所有的计算结果，
只需要保留上一次的即可，因此算法的时间和空间复杂度都很小。

PS:第二种方法又称为扫描法，它的最初思想是：
当我们加上一个正数时，和会增加；
当我们加上一个负数时，和会减少。
如果当前得到的和是个负数，那么这个和在接下来的累加中应该抛弃并重新清零，不然的话这个负数将会减少接下来的和。

-----------------以下证明摘自博客----------------------------------
作者：zwzsdy 
来源：CSDN 
原文：https://blog.csdn.net/zwzsdy/article/details/80029796 

这个算法如此精炼简单，而且复杂度只有线性。但是我想，能想出来却非常困难，而且证明也不简单。在这里，我斗胆写出自己证明的想法：
关于这道题的证明，我的思路是去证明这样的扫描法包含了所有n^2种情况，即所有未显示列出的子数组都可以在本题的扫描过程中被抛弃。

1 首先，假设算法扫描到某个地方时，始终未出现加和小于等于0的情况。
我们可以把所有子数组（实际上为当前扫描过的元素所组成的子数组）列为三种：
  1.1 以开头元素为开头，结尾为任一元素的子数组
  1.2 以结尾元素为结尾，开头为任一元素的子数组
  1.3 开头和结尾都不等于当前开头结尾的所有子数组（中间区间的数组）
1.1由于遍历过程中已经扫描，所以算法已经考虑了。
1.2确实没考虑，但我们随便找到1.2中的某一个数组，
可知，从开头元素到这个1.2中的数组的加和大于0（因为如果小于0就说明扫描过程中遇到小于0的情况，不包括在大前提1之内），
那么这个和一定小于从开头到这个1.2数组结尾的和。故此种情况可舍弃。
1.3 可以以1.2同样的方法证明，因为我们的结尾已经列举了所有的情况，那么每一种情况和1.2是相同的，故也可以舍弃。

2 如果当前加和出现小于等于0的情况，且是第一次出现，可知前面所有的情况加和都不为0
一个很直观的结论是，如果子段和小于0，我们可以抛弃，但问题在于是不是他的所有以此子段结尾为结尾而开头任意的子段也需要抛弃呢？
答案是肯定的。因为以此子段开头为开头而结尾任意的子段加和都大于0（情况2的前提），所以这些子段的和是小于当前子段的，也就是小于0的，
对于后面也是需要抛弃的。也就是说，所有以之前的所有元素为开头而以当前结尾之后元素为结尾的数组都可以抛弃了。
而对于后面抛弃后的数组，则可以同样递归地用1 2两个大情况进行分析，于是得证。
*/

