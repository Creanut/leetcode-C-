/*
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
*/

int removeDuplicates(int* nums, int numsSize) 
{
    if(numsSize == 0)
        return 0;
    int i = 0;
    int j = 1;
    for(j = 1;j < numsSize;j++)
    {
        if(nums[j] != nums[i])//这里也可以写成“nums[j] != nums[j-1]”
        {
            nums[i+1] = nums[j];
            i++;
        }
    }
    return i + 1;
}

/*
题目中的重点有二：
其一：给定的数组是排序后的数组，也就是说重复数字一定是连续的，且数组中不会出现相同的重复段；
其二：题目要求不增加额外的内存开销，删除元素（或者重构数组）必须在给定的原数组上直接进行操作。
针对问题1，解决方法可以简化为，定义一个元素计数器（初始值为1），从数组的第一个元素开始遍历所有元素，一旦数组元素出现跳变沿（即相邻元素不相同），
元素计数器就自加1，这样遍历到最后的计数器的值一定是数组中不同元素的个数，这是因为有“排序后数组”这一条件作为保证。
针对问题2，如果使用针对问题1的解决方案，自然的想法是构建一个链表或者其他动态存储空间，根据遍历过程中跳变沿的出现情况，随时注入新的元素，但是这样
就需要开辟新的内存，不符合题目要求。所以在原数组的基础上进行新的数组的构建，另外一个思路就是使用两个指针分别进行“遍历数组元素”和“构建新的数组”两个
动作：
第一个指针j从原数组的第2个元素开始边比较，边自增（实现寻找跳变沿的目的）；
第一个指针i则从原数组的第一个元素开始维护一个用数组定义的栈，入栈信号是跳变沿，入栈元素是指针j指向的元素。
这样分析下来，编程思路就是：
j从第二个元素开始进行自增操作以实现数组元素的遍历；
在遍历过程中，不断与前一个元素进行比较，寻找跳变沿；
如果出现跳变沿，将信号传递给栈维护指针i，传递当前指向的元素入栈；
遍历结束后，返回栈内元素个数即可。
*/
