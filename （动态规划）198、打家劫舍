/*
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2:

输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
*/

int rob(int* nums, int numsSize) 
{    
    if(numsSize == 0)
        return 0;
    if(numsSize == 1)
        return nums[0];
    if(numsSize == 2)
        return nums[0] > nums[1] ? nums[0] : nums[1];
    
    int profit[numsSize];
    
    profit[0] = nums[0];
    profit[1] = (nums[0] > nums[1]) ? nums[0] : nums[1];
    
    for(int i = 2; i < numsSize; i++)
    {
        profit[i] = ((profit[i - 2] + nums[i]) > profit[i - 1]) ? profit[i - 2] + nums[i] : profit[i - 1];
    }
    
    return profit[numsSize - 1];
}

/*
这道题目真的是简单题吗？ORZ……
---------------------------以下内容摘自博客-----------------------
作者：追风筝的咸鱼 
来源：CSDN 
原文：https://blog.csdn.net/zw159357/article/details/82355140 
版权声明：本文为博主原创文章，转载请附上博文链接！

题解：先从简单的思路开始
只有一家：[1] ，偷到的最高金额就是1
有两家：[1,2]，偷到的最高金额就是这两家中的最大值2
有三家：[1,2,3]，这时偷到的最高金额就是第一家和第三家的和4，
这里会有个判断，如果先从第二家开始偷是否会比先从第一家偷后的金额多，最后金额就是去这两种情况中的最大值，

有四家：[1,2,3,4]，这时我们能看出偷出的最高金额是6，那么又是怎么判断出来的呢，
遍历数组，把从第一家开始偷到最后获得的总金额算出来，再把从第二家开始偷到最后的总金额算出来，选择其中数值较大的那个，
是这样吗，好像不是，
题目要求不让偷相邻的意思是允许一次隔大于等于一家进行偷，而不是固定只能隔一家偷。
那又该怎样解决这个问题呢，先看一种特殊情况[2,1,1,2]，这时最后偷得最大金额是4，
我们可以这样想从第一家开始，第一家最大偷盗金额是2，第二家也是2，第三家是3，第四家是4，
这里我们需要注意的是
这里第四家计算的时候是第二家能偷到的最大金额加上第四家偷到的金额与第三家能偷到的最大金额的最大值，体会一下。

想把动态规划用好，还得多练多总结，自己考虑问题的时候一定要尽可能考虑全面。
*/
