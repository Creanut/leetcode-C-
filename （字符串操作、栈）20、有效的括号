/*
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:

输入: "()"
输出: true
示例 2:

输入: "()[]{}"
输出: true
示例 3:

输入: "(]"
输出: false
示例 4:

输入: "([)]"
输出: false
示例 5:

输入: "{[]}"
输出: true
*/

bool isValid(char* s) 
{
	int len = strlen(s);
	char* stack = malloc(sizeof(char)*len);
	size_t size = 0;
	for (int i = 0; i < len; i++) 
  {
      char c = s[i];//读取字符串中的当前字符的值
      if (c == ')') //遇到右括号时判断栈顶是否是与之匹配的左括号
      {
        if (size==0 || stack[--size] != '(') 
          return false;
      }
      else if (c == ']') 
      {
        if (size == 0 || stack[--size] != '[') 
          return false;
      }
      else if (c == '}') 
      {
        if (size == 0 || stack[--size] != '{') 
          return false;
      }
      else //遇到左括号，则入栈
      {
        stack[size++]=c;
      }
	}
	return size==0;
}

/*
对于括号的顺序匹配问题，使用栈来解决这种对应的顺序问题是最简单最直观的。
对于满足题意的合法表示，例如：
() / [] / {}最简单的合法括号组
()()()() / ()[]{}并列的合法括号组
((())) / (()(()))对称嵌套与不对称嵌套的合法括号组
{([])} / {(){[()]}}混合嵌套的合法括号组
在以上的合法情况中可以看出，如果只要遇到左括号（'('、'['、'{'）则将其顺次存入栈中，
遇到右括号则将其与栈顶的符号进行匹配判断，如果匹配则说明该对符号合法，栈顶弹出，后续符号接着进行比较。
其思想是，在合法字符串中，最先检索到的左括号，与其匹配的右括号肯定是最后被检索到，所以应该使用“栈”的结构来存储。
对于非合法字符串，例如：
(( / {{ / [[ 仅有左侧括号，这些进行正常入栈，但是没有检索到与之配合的右括号，则最后栈非空，false
[() 最后栈非空
)) 仅有右侧括号，栈为空
*/
