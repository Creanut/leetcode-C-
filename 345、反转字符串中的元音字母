/*
编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

示例 1:

输入: "hello"
输出: "holle"
示例 2:

输入: "leetcode"
输出: "leotcede"
说明:
元音字母不包含字母"y"。
*/

char* reverseVowels(char* s) 
{
    char temp;
    int i = 0,j = strlen(s) - 1;
    while(i < j)
    {
        for(;i < j;i++)
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')
                break;
        for(;i < j;j--)
            if(s[j] == 'a' || s[j] == 'e' || s[j] == 'i' || s[j] == 'o' || s[j] == 'u' || s[j] == 'A' || s[j] == 'E' || s[j] == 'I' || s[j] == 'O' || s[j] == 'U')
                break;
        temp = s[i];
        s[i] = s[j];
        s[j] = temp;
        i++;
        j--;
    }
    return s;
}

/*
本题思路和反转字符串的思路一致，使用双指针对对应元素进行对调。
这里需要注意的一个技巧是for循环中break的运用：
由于这里只需要对调字符串中的元音字母，所以要保证头指针i和尾指针j
都指向元音字母的时候才进行元素对调，所以要解决一个指针已经指向
元音字母，另一个指针还没有指向元音字母时的数组下标保护工作。
这一问题可使用for循环中的break来解决，首尾指针分别使用各自的for循环
进行遍历，当遍历过程中遇到元音字符时使用break语句跳出各自的循环，
可以认为是对下标进行一种保护；只有当两个指针都指向元音字母时，
才执行对调元素操作。
*/
