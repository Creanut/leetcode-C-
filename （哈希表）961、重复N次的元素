/*
在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。

返回重复了 N 次的那个元素。

 

示例 1：

输入：[1,2,3,3]
输出：3
示例 2：

输入：[2,1,2,5,3,2]
输出：2
示例 3：

输入：[5,1,5,2,5,3,5,4]
输出：5
 

提示：

4 <= A.length <= 10000
0 <= A[i] < 10000
A.length 为偶数
*/

int repeatedNTimes(int* A, int ASize)
{
    int* hash = (int*)calloc(10000 , sizeof(int));
    
    
    for(int i = 0; i < ASize; i++)
    {
        hash[A[i]]++;
        if(hash[A[i]] >= 2)
            return A[i];
    }
    
    return 0;
}

/*
比较讨巧的是，题目中说明了2N个元素中，除了那个重复N次的元素，
其余元素都只出现N次，且数字总数不会超过10000.
因此直接建立一个hash表即可，key值为数组中的元素值，value值为该元素
出现的次数。如果元素出现的次数大于等于2，则说明这个值就是占据半壁江山的那个值。

注意这里和那个找众数的题目不同，不能直接使用摩尔投票法，
摩尔投票法的应用原则是待投出的元素数目要过半，恰好一半是不行的。
*/
