/*
给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使 n - 1 个元素增加 1。

示例:

输入:
[1,2,3]

输出:
3

解释:
只需要3次移动（注意每次移动会增加两个元素的值）：

[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
*/

int minMoves(int* nums, int numsSize)
{
    int min = nums[0];
    int sum = 0;
    
    for(int i = 0; i < numsSize; i++)
        min = (min > nums[i]) ? nums[i] : min;

    for(int i = 0; i < numsSize; i++)
        sum += (nums[i] - min);
    
    return sum;
}

/*
这道题表面上理解起来很绕，其实把“移动”换成“操作”就会很好理解。

给定一个数组，里面有若干数字，要经过若干次操作使得数组的数都相等，
其中每操作一次，可以使数组中的n - 1个元素增加1.
很自然的想法就是，每次操作选定的增加1的元素就是除了当前最大值之外的
其他n-1个元素。

反过来想，也就相当于是每次操作中有一个元素自身减一，因为只能做减法，
所以数组最后的数只能是最小值，这样的话，每个元素减去最小值求其和就是答案。
*/
