/*
给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

示例 1:

输入: [3,2,3]
输出: 3
示例 2:

输入: [2,2,1,1,1,2,2]
输出: 2
*/

int majorityElement(int* nums, int numsSize) 
{
    int result = nums[0];
    int cnt = 1;
    
    for(int i = 1; i < numsSize; i++)
    {
        if(nums[i] != result)
            cnt--;
        else
            cnt++;
        
        if(cnt == 0)
        {
            i++;
            result = nums[i];
            cnt++;
        }
    }
    
    return result;
}

/*
这道题用到的算法是“摩尔投票法”。
先假设result是第一个数，然后从第二个数开始遍历，遇见相同的就+1，不同的就-1，
如果count==0，就result赋值为下一个数，接着遍历，最后result的值 就是结果。
该方法的思想是众数一定比其他所有的数加起来的数量要多，就算是众数与其他每一个数相抵消，最后剩下来的也是众数。
况且还有其他数之间的抵消，所以剩下来的一定是众数。

---------------------以下文章摘自https://www.jianshu.com/p/c19bb428f57a---------------------
作者：Jimmy5Zhang
链接：https://www.jianshu.com/p/c19bb428f57a
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

提问： 给定一个int型数组，找出该数组中出现次数大于数组长度一半的int值。
解决方案： 遍历该数组，统计每个int值出现次数，再遍历该数组，找出出现次数大于数组长度一半的int值。
同样的，该解决办法也要求使用Map，否则无法达到线性的时间复杂度。
那么对于这个问题，有没有什么不使用Map的线性算法呢？
答案就是今天我们要提到的摩尔投票法。利用该算法来解决这个问题，我们可以达到线性的时间复杂度以及常量级的空间复杂度。
首先我们注意到这样一个现象： 在任何数组中，出现次数大于该数组长度一半的值只能有一个。
通过数学知识，我们可以证明它的正确性，但是这并不在我们这篇博客里涉及。
摩尔投票法的基本思想很简单，在每一轮投票过程中，从数组中找出一对不同的元素，将其从数组中删除。
这样不断的删除直到无法再进行投票，如果数组为空，则没有任何元素出现的次数超过该数组长度的一半。如果只存在一种元素，那么这个元素则可能为目标元素。
那么有没有可能出现最后有两种或两种以上元素呢？
根据定义，这是不可能的，因为如果出现这种情况，则代表我们可以继续一轮投票。因此，最终只能是剩下零个或一个元素。
在算法执行过程中，我们使用常量空间实时记录一个候选元素c以及其出现次数f(c)，c即为当前阶段出现次数超过半数的元素。
根据这样的定义，我们也可以将摩尔投票法看作是一种动态规划算法。
程序开始之前，元素c为空，f(c)=0。遍历数组A：

如果f(c)为0，表示截至到当前子数组，并没有候选元素。
也就是说之前的遍历过程中并没有找到超过半数的元素。
那么，如果超过半数的元素c存在，那么c在剩下的子数组中，出现次数也一定超过半数。
因此我们可以将原始问题转化为它的子问题。此时c赋值为当前元素, 同时f(c)=1。
如果当前元素A[i] == c, 那么f(c) += 1。(没有找到不同元素，只需要把相同元素累计起来)
如果当前元素A[i] != c，那么f(c) -= 1 (相当于删除1个c)，不对A[i]做任何处理(相当于删除A[i])

如果遍历结束之后，f(c)不为0，则找到可能元素。
再次遍历一遍数组，记录c真正出现的次数，从而验证c是否真的出现了超过半数。
上述算法的时间复杂度为O(n)，而由于并不需要真的删除数组元素，我们也并不需要额外的空间来保存原始数组，空间复杂度为O(1)。
*/
