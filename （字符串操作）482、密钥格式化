/*
给定一个密钥字符串S，只包含字母，数字以及 '-'（破折号）。N 个 '-' 将字符串分成了 N+1 组。给定一个数字 K，重新格式化字符串，除了第一个分组以外，每个分组要包含 K 个字符，第一个分组至少要包含 1 个字符。两个分组之间用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。

给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。

示例 1：

输入：S = "5F3Z-2e-9-w", K = 4

输出："5F3Z-2E9W"

解释：字符串 S 被分成了两个部分，每部分 4 个字符；
     注意，两个额外的破折号需要删掉。

示例 2：

输入：S = "2-5g-3-J", K = 2

输出："2-5G-3J"

解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。

 

提示:

    S 的长度不超过 12,000，K 为正整数
    S 只包含字母数字（a-z，A-Z，0-9）以及破折号'-'
    S 非空
*/

char * licenseKeyFormatting(char * S, int K)
{
    int S_len = strlen(S);
    int result_len = S_len * 2;
    char* result = (char*)malloc((result_len+1) * sizeof(char));
    result[result_len] = '\0';
    int valid_cnt = 1;//有效字符的个数
    int sign_cnt = 0;//-的个数
    
    //从末端开始循环
    for(int i = S_len - 1; i >= 0; i--)
    {
        if(S[i] == '-')//忽略原字符串中的-
            continue;
        if(S[i] <= 'z' && S[i] >= 'a')//将原字符串中的小写字母转成大写字母
            S[i] = S[i] - 'a' + 'A';
        result[result_len - valid_cnt - sign_cnt] = S[i];//将转换后的字母放到对应的位置上
        
        if(valid_cnt % K == 0)//组与组之间的间隔处，添加-
        {
            sign_cnt++;
            result[result_len - valid_cnt - sign_cnt] = '-';
        }
        valid_cnt++;
    }
    //返回数组的起始位置，如果首位置是-，则说明字符个数等分，返回的数组指针需要略去首位置的-
    return result[result_len-valid_cnt-sign_cnt+1] != '-' ? result + result_len - valid_cnt - sign_cnt + 1 : result + result_len - valid_cnt - sign_cnt + 2 ; 
}

/*
这是一道典型的字符串操作题，按照流程办事即可。
按照题目要求，格式化后的字符分成若干组，第一组的字符个数可以小于K，后面每一组的字符个数必须等于K，
且组与组之间需要使用‘-’连接，所以可以考虑从所给的字符串的末端开始往前遍历，并在遍历过程中略去-，
并将所有的小写字母转换为大写字母，转换后的字母也是从后到前依次往前填充即可。
对于组与组之间的‘-’，当遍历的字符个数为K的倍数时，则说明下一个字符要赋值为‘-’。

对于初始化字符串数组的长度，
最坏的情况是原字符串中全部都是字母，没有‘-’，然后给定的K值为1，这样就需要在格式化前预分配原字符串
两倍长的内存来存储。所以初始化时，预分配的内存是原字符串长度的两倍。
*/
