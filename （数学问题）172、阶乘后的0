/*
给定一个整数 n，返回 n! 结果尾数中零的数量。

示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:

输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
说明: 你算法的时间复杂度应为 O(log n) 。
*/

int trailingZeroes(int n) 
{
    int num = 0;
    while(n > 0)
    {
        n /= 5;
        num += n;
    }
    return num;
}

/*
感觉又是一道智力题 -_-||

最直观的想法 直接把数字的阶乘算出来，但是这样稳稳的上溢。
比如5 的阶乘是120 后面有一个0. 为了统计处这样的0 有多少个。我们只需要知道所有可能的数字 里面相乘 可以得到10 的个数。
比如5! = 5*4*3*2*1 其中 5*2得到10；这就是最后一个0 的来源。
再思考一下，要得到整数10 只能由 2*5 得到，我们可以把问题转换成为 寻找<n 的所有数字中 的分解 因子中的2 和5 的个数。一个2和一个5 就能构成10 。
比如10！ =(2*5)*9*(2*4)*7*(2*3)*(5*1)*(2*2)*3*(2*1)
其中有 6个2 2个5 只能构成两个10 所以 10 的结果应该是2 。
并且我们发现统计2的个数没有意义的。2 的个数必然比5 多。因此我们只需要统计5 的个数就行了。
如何统计5的个数？
例如拿10来举例：
10! = 10*9*8*7*6*5*4*3*2*1
第一步：对10除5，相当于将1到10中所有“第一个”5因子提取出来。(10=5*2中的5，5中的5)
第二步：对10除25，结果为0，退出循环。（此步目的是提取出1到10中的所有“第二个”5因子）
*/
